using ARDC.NetCore.Playground.API.Features.Games;
using ARDC.NetCore.Playground.Domain.Models;
using ARDC.NetCore.Playground.Domain.Repositories;
using ARDC.NetCore.Playground.Persistance.Mock.Generators;
using FluentAssertions;
using Microsoft.AspNetCore.Mvc;
using Moq;
using System;
using System.Collections.Generic;
using Xunit;

namespace ARDC.NetCore.Playground.API.UnitTests.Features
{
    public class GameTest
    {
        private readonly IModelGenerator<Game> _gameGenerator;
        private readonly Mock<IGameRepository> _mockRepository;
        private readonly GameController _controller;

        public GameTest()
        {
            _gameGenerator = new GameGenerator();
            _mockRepository = new Mock<IGameRepository>();
            _controller = new GameController(_mockRepository.Object);
        }

        /// <summary>
        /// It should be possible to get a list of games.
        /// </summary>
        [Theory(DisplayName = "Get many Games")]
        [InlineData(2)]
        [InlineData(20)]
        [InlineData(50)]
        [InlineData(1)]
        public void GetGames(int count)
        {
            _mockRepository.Setup(m => m.Get()).Returns(_gameGenerator.Get(count));
            var result = _controller.Get();

            result.Should()
                .NotBeNull("a result is always expected").And
                .BeAssignableTo<IActionResult>("it should implement IActionResult").And
                .BeOfType<OkObjectResult>("it should be an OK result")
                .Which
                .Value.Should()
                    .NotBeNull("an object is always expected, even if empty").And
                    .BeAssignableTo<IList<Game>>("it should implement IList<T>").And
                    .BeOfType<List<Game>>("it should be a List of Games");

            var games = (result as OkObjectResult).Value as List<Game>;
            games.Should()
                .NotBeEmpty("its repository has elements").And
                .HaveCount(count, $"its repository has {count} elements");
        }

        /// <summary>
        /// It should be possible to get a single game.
        /// </summary>
        [Fact(DisplayName = "Get an Existing Game")]
        public void GetGame()
        {
            var fakeGame = _gameGenerator.Get();
            _mockRepository.Setup(m => m.Get(It.IsAny<string>())).Returns(fakeGame);
            var result = _controller.Get("gameId");

            // TODO: Futuramente o Controller poderá retornar 404 Not Found, preciso ver como testas estes casos.

            result.Should()
                .NotBeNull("a result is always expected").And
                .BeAssignableTo<IActionResult>("it should implement IActionResult").And
                .BeOfType<OkObjectResult>("it should be an OK result")
                .Which
                .Value.Should()
                    .NotBeNull("a result is always expected").And
                    .BeOfType<Game>("it should be a Game");

            var game = (result as OkObjectResult).Value as Game;
            game.Should()
                .BeEquivalentTo(fakeGame, "should be the same game as the one returned by the Repository");

        }
        
        /// <summary>
        /// It should be possible to create a game.
        /// </summary>
        [Fact(DisplayName = "Create a Game")]
        public void CreateGame()
        {
            var newGame = new Game
            {
                Name = "Pudim of War",
                ReleasedOn = DateTime.Now.AddYears(-2)
            };

            _mockRepository.Setup(m => m.Create(It.IsAny<Game>())).Returns(() =>
            {
                newGame.Id = Guid.NewGuid().ToString();
                return newGame;
            });

            // TODO: Futuramente o controller poderá falhar em creates, rever este teste.

            var result = _controller.Create(newGame);
            result.Should()
                .NotBeNull("a result is always expected").And
                .BeAssignableTo<IActionResult>("should implement IActionResult").And
                .BeOfType<CreatedResult>("be of type Created")
                .Which
                .Value.Should()
                    .NotBeNull("it should mimic the game we sent to the controller").And
                    .BeOfType<Game>("it is created as a game")
                    .Which
                    .Id.Should()
                        .NotBeNullOrWhiteSpace("it should be generated by the Repository");

            var createdGame = (result as CreatedResult).Value;
            createdGame.Should().BeEquivalentTo(newGame, opt => opt.ExcludingMissingMembers(), "it was created using newGame itself");
        }

        /// <summary>
        /// It shouldn't be possible to create a game which already has an ID.
        /// </summary>
        [Fact(DisplayName = "Create an existing Game")]
        public void CreateDuplicateGame()
        {
            var newGame = _gameGenerator.Get();

            _mockRepository.Setup(m => m.Create(newGame)).Throws<Exception>();

            var result = _controller.Create(newGame);

            result.Should()
                .NotBeNull("a result is always expected").And
                .BeAssignableTo<IActionResult>("it should implement IActionResult").And
                .BeOfType<BadRequestResult>("it should be a Bad Request");
        }

        /// <summary>
        /// It should be possible to update an existing game.
        /// </summary>
        [Fact(DisplayName = "Update a Game")]
        public void UpdateGame()
        {
            var game = new Game
            {
                Id = "pudimofwar",
                Name = "Pudim War",
                ReleasedOn = DateTime.Now
            };

            _mockRepository.Setup(m => m.Update(It.IsAny<string>(), It.IsAny<Game>()));

            var result = _controller.Update(game.Id, game);
            result.Should()
                .NotBeNull("a result is always expected").And
                .BeAssignableTo<IActionResult>("it should implement IActionResult").And
                .BeOfType<OkResult>("it should return OK");
        }

        /// <summary>
        /// It should be possible to delete an existing game.
        /// </summary>
        [Fact(DisplayName = "Delete a Game")]
        public void DeleteGame()
        {
            _mockRepository.Setup(m => m.Delete(It.IsAny<string>()));
            _mockRepository.Setup(m => m.Delete(It.IsAny<Game>()));

            var result = _controller.Delete("gameId");

            result.Should()
                .NotBeNull("a result is always expected").And
                .BeAssignableTo<IActionResult>("it should implement IActionResult").And
                .BeOfType<NoContentResult>("it should have No Content");
        }
    }
}
