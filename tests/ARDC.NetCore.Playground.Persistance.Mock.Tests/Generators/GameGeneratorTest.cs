using ARDC.NetCore.Playground.Domain.Models;
using ARDC.NetCore.Playground.Persistence.Mock.Generators;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using Xunit;

namespace ARDC.NetCore.Playground.Persistence.Mock.Tests.Generators
{
    /// <summary>
    /// Tests for the GameGenerator.
    /// </summary>
    public class GameGeneratorTest : IClassFixture<ServiceProviderFixture>
    {
        private readonly IModelGenerator<Game> _gameGenerator;

        public GameGeneratorTest(ServiceProviderFixture fixture)
        {
            _gameGenerator = fixture.Provider.GetService<IModelGenerator<Game>>();
        }

        /// <summary>
        /// It should be possible to generate a single game.
        /// </summary>
        [Fact(DisplayName = "Create Single Game")]
        public void CreateSingle()
        {
            var game = _gameGenerator.Get();

            game.Should()
                .NotBeNull("should have been generated as a whole").And
                .NotBeOfType<IList<Game>>("should be a single object").And
                .BeOfType<Game>("should be a Game object");

            game.Id.Should().NotBeNullOrWhiteSpace("should have been generated by a Guid");
            game.Name.Should().NotBeNullOrWhiteSpace("should have been generated by Bogus");
            game.ReleasedOn.Should().BeBefore(DateTime.Now, "should have been released in the past");
        }

        /// <summary>
        /// It should be possible to generate a set number of games.
        /// </summary>
        /// <param name="count">Amount of games to be generated</param>
        [Theory(DisplayName = "Create Many Games")]
        [InlineData(2)]
        [InlineData(20)]
        [InlineData(200)]
        [InlineData(15)]
        public void CreateMany(int count)
        {
            var games = _gameGenerator.Get(count);  // TODO: Tratar quantidades negativas e zero

            games.Should()
                .NotBeNull("should have been generated as a whole").And
                .BeAssignableTo<IList<Game>>("should implement IList<T>").And
                .BeOfType<List<Game>>("should be created as a List<T>").And
                .NotBeEmpty("IModelGenerator<T> does not create blanks").And
                .HaveCount(count, "should respect the count param");
        }

        /// <summary>
        /// It should be possible to generate a number of games within a Range.
        /// </summary>
        /// <param name="min">The minimum amount</param>
        /// <param name="max">The maximum amount</param>
        [Theory(DisplayName = "Create a Range of Games")]
        [InlineData(2, 10)]
        [InlineData(20, 20)]
        [InlineData(200, 201)]
        [InlineData(15, 30)]
        public void CreateRange(int min, int max)
        {
            var games = _gameGenerator.Get(min, max);   // TODO: Tratar quantidades negativas, zero e min maior que max.

            games.Should()
                .NotBeNull("should have been generated as a whole").And
                .BeAssignableTo<IList<Game>>("should implement IList<T>").And
                .BeOfType<List<Game>>("should be created as a List<T>").And
                .NotBeEmpty("IModelGenerator<T> does not create blanks").And
                .HaveCountGreaterOrEqualTo(min, "should respect the min param").And
                .HaveCountLessOrEqualTo(max, "should respect the max param");
        }
    }
}
